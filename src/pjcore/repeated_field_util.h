// JSON [de]serialization for protobuf + embedded HTTP server and client in C++.
// Copyright (C) 2014 http://protojson.com/
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

#ifndef PJCORE_REPEATED_FIELD_UTIL_H_
#define PJCORE_REPEATED_FIELD_UTIL_H_

#include <assert.h>

#include "google/protobuf/repeated_field.h"

#include "pjcore/logging.h"

/**
 * Google's Protobuf library provides google::protobuf::RepeatedPtrField
 * template containers for
 * object types that take care of the allocated objects referenced by pointers.
 * google::protobuf::RepeatedPtrField<T> has two advantages over
 * std::vector<std::unique_ptr<T>>:
 * it doesn't require C++11, and it is compatible with the repeated fields of
 * message classes, generated by Protobuf compiler. There're disadvantages, too,
 * such as lack of empty(), front(), back(), push_back() and pop_back() methods,
 * but that can be addressed by defining top-level functions with similar names,
 * and passing them the actual google::protobuf::RepeatedPtrField<T> as the
 * first parameter.
 * For google::protobuf::RepeatedField<T>, there's no first advantage over
 * std::vector<T>, but
 * there is still second, so the functions provided for it, too.
 */
namespace pjcore {

/**
 * Tells if a colleciton is empty.
 */
template <typename Element>
bool Empty(const google::protobuf::RepeatedField<Element>& repeated) {
  return repeated.size() == 0;
}

/**
 * Tells if a colleciton is empty.
 */
template <typename Element>
bool Empty(const google::protobuf::RepeatedPtrField<Element>& repeated) {
  return repeated.size() == 0;
}

/**
 * Returns a const reference to the front (first) element of a collection,
 * which is passed by a const reference itself. Checks for the collection to be
 * non-empty, but only in a debug build (without NDEBUG defined).
 */
template <typename Element>
const Element& Front(const google::protobuf::RepeatedField<Element>& repeated) {
  assert(repeated.size() > 0);
  return repeated.Get(0);
}

/**
 * Returns a const reference to the front (first) element of a collection,
 * which is passed by a const reference itself. Checks for the collection to be
 * non-empty, but only in a debug build (without NDEBUG defined).
 */
template <typename Element>
const Element& Front(
    const google::protobuf::RepeatedPtrField<Element>& repeated) {
  assert(repeated.size() > 0);
  return repeated.Get(0);
}

/**
 * Returns a pointer to the front (first) element of a collection, which is
 * passed by a pointer itself. Checks for the collection to be non-empty, but
 * only in a debug build (without NDEBUG defined).
 */
template <typename Element>
Element* MutableFront(google::protobuf::RepeatedField<Element>* repeated) {
  assert(repeated->size() > 0);
  return repeated->Mutable(0);
}

/**
 * Returns a pointer to the front (first) element of a collection, which is
 * passed by a pointer itself. Checks for the collection to be non-empty, but
 * only in a debug build (without NDEBUG defined).
 */
template <typename Element>
Element* MutableFront(google::protobuf::RepeatedPtrField<Element>* repeated) {
  assert(repeated->size() > 0);
  return repeated->Mutable(0);
}

/**
 * Returns a const reference to the back (last) element of a collection,
 * which is passed by a const reference itself. Checks for the collection to be
 * non-empty, but only in a debug build (without NDEBUG defined).
 */
template <typename Element>
const Element& Back(const google::protobuf::RepeatedField<Element>& repeated) {
  assert(repeated.size() > 0);
  return repeated.Get(repeated.size() - 1);
}

/**
 * Returns a const reference to the back (last) element of a collection,
 * which is passed by a const reference itself. Checks for the collection to be
 * non-empty, but only in a debug build (without NDEBUG defined).
 */
template <typename Element>
const Element& Back(
    const google::protobuf::RepeatedPtrField<Element>& repeated) {
  assert(repeated.size() > 0);
  return repeated.Get(repeated.size() - 1);
}

/**
 * Returns a pointer to the back (last) element of a collection, which is
 * passed by a pointer itself. Checks for the collection to be non-empty, but
 * only in a debug build (without NDEBUG defined).
 */
template <typename Element>
Element* MutableBack(google::protobuf::RepeatedField<Element>* repeated) {
  assert(repeated->size() > 0);
  return repeated->Mutable(repeated->size() - 1);
}

/**
 * Returns a pointer to the back (last) element of a collection, which is
 * passed by a pointer itself. Checks for the collection to be non-empty, but
 * only in a debug build (without NDEBUG defined).
 */
template <typename Element>
Element* MutableBack(google::protobuf::RepeatedPtrField<Element>* repeated) {
  assert(repeated->size() > 0);
  return repeated->Mutable(repeated->size() - 1);
}

/**
 * Adds a copy of an object at the end of the collection, after its current back
 * (last) element.
 */
template <typename Element>
void PushBack(google::protobuf::RepeatedField<Element>* repeated,
              const Element& value) {
  repeated->Add(value);
}

/**
 * Adds a copy of an object at the end of the collection, after its current back
 * (last) element.
 */
template <typename Element>
void PushBack(google::protobuf::RepeatedPtrField<Element>* repeated,
              const Element& value) {
  repeated->Add(value);
}

/**
 * Adds an empty object at the end of the collection, after its current back
 * (last) element, and return a pointer to the result element.
 */
template <typename Element>
Element* PushBack(google::protobuf::RepeatedField<Element>* repeated) {
  return repeated->Add();
}

/**
 * Adds an empty object at the end of the collection, after its current back
 * (last) element, and return a pointer to the result element.
 */
template <typename Element>
Element* PushBack(google::protobuf::RepeatedPtrField<Element>* repeated) {
  return repeated->Add();
}

/**
 * Removes the back (last) element in the collection, effectively reducing its
 * size by one. Checks for the collection to be non-empty, but only in a debug
 * build (without NDEBUG defined).
 */
template <typename Element>
void PopBack(google::protobuf::RepeatedField<Element>* repeated) {
  assert(repeated->size() > 0);
  repeated->RemoveLast();
}

/**
 * Removes the back (last) element in the collection, effectively reducing its
 * size by one. Checks for the collection to be non-empty, but only in a debug
 * build (without NDEBUG defined).
 */
template <typename Element>
void PopBack(google::protobuf::RepeatedPtrField<Element>* repeated) {
  assert(repeated->size() > 0);
  repeated->RemoveLast();
}

template <typename Element>
void Resize(google::protobuf::RepeatedField<Element>* repeated, int new_size) {
  if (new_size < repeated->size()) {
    repeated->Truncate(new_size);
  } else {
    repeated->Reserve(new_size);
    while (repeated->size() < new_size) {
      repeated->Add();
    }
  }
}

template <typename Element>
void Resize(google::protobuf::RepeatedPtrField<Element>* repeated,
            int new_size) {
  if (new_size < repeated->size()) {
    while (repeated->size() > new_size) {
      repeated->RemoveLast();
    }
  } else {
    repeated->Reserve(new_size);
    while (repeated->size() < new_size) {
      repeated->Add();
    }
  }
}

}  // namespace pjcore

#endif  // PJCORE_REPEATED_FIELD_UTIL_H_
